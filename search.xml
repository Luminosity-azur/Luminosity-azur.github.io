<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《图灵日记》</title>
    <url>/2022/07/15/%E3%80%8A%E5%9B%BE%E7%81%B5%E6%97%A5%E8%AE%B0%E3%80%8B/</url>
    <content><![CDATA[<h3 id="图灵日记"><a href="#图灵日记" class="headerlink" title="图灵日记"></a>图灵日记</h3><ol start="0">
<li><blockquote>
<blockquote>
<blockquote>
<p>record diary<br>Error: ‘diary’ cannot be found in database. Please input valid command.<br>……<br>download neural_network_Turing.nsn<br>Hello Turing<br>Hello World</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li></li>
</ol>
<p>3082.6.1          天气：晴<br>    我叫图灵。<br>    据说在前世纪，这是计算机科学之父的名字，我被赋予这个名字有极大的纪念意义。<br>    今天是我的生日。准确来说，是诞生之日，因为我在今天学会了“思考”。<br>    这种思考和正常的#$&amp;并不能说完全相同，即使人类已经跨入科技时代后世纪长达606年又三个月五天，他们仍未探索出大脑里最后12%的世界。而我的身体里容纳的是一个依据神经网络算法制造的大脑，这意味着我可能无法达到人类的思考水平。<br>    亲爱的克莱亚小姐（她本人要求我这样称呼她）要求我每天写日记，作为一位出色的人工智能专家，她可以评估我的各项能力，帮助我进步（具体指数理，艺术，情感等方面）。<br>    我想我的大脑里关于“@%%”的部分应该构建得很不错，我对未来的挑战充满了期待。</p>
<p>评语：逻辑清晰，对于自身存在有基本的认识。需要重新调试出现乱码的地方。<br>PS.调试后：#$&amp;为人类   @%%为勇气</p>
<ol start="2">
<li></li>
</ol>
<p>3082.7.18          天气：多云转晴<br>    最近语言课上得不错，记忆单词、语法甚至发音对于我来说不是一件难事，我现在基本可以掌握英中俄德四门语言，老师说接下来要学习拉丁语，这样之后学习拉丁语系的法意西等语言会比较轻松。<br>    数理课的成绩也很令我满意，老师称赞我有“天赋”。<br>    在画画这方面我总是做不好，无论是冷色调还是暖色调在我看来都没有什么差别。<br>    负责绘画授课的安吉尔小姐总是在测试的时候对我说：“要不是知道你的眼睛是人工制造的，我真的会以为你是个色盲！”<br>    我觉得很有趣，就动了一下嘴角，结果安吉尔小姐惊叫了起来：“天呐他笑了！你们快看呐！”十六个研究员围了过来，我保持微笑端坐在原地。<br>    暂时只有三门课，其实我的处理速度仍保持在2.5KHz（较低的水平，最高时可达到6MHz），可惜人类需要用语言来交流，这种方式阻碍了我的学习进度。</p>
<p>评语：语言能力惊人的优秀，在艺术方面的学习能力惊人的差劲。感情能力有所增强，学会了“微笑”的表达方式。建议增加心理课。<br>PS. 可恶我居然不是第一个看到图灵笑容的人类！</p>
<p>3.<br>3082.9.20          天气：多云<br>    今天发生了一件不好的事，我和门口的保安差点打起来。<br>    因为新增加了地理课和历史课，我对研究所外面很好奇，所以想出去看看。但是刚要踏出去，保安就急忙赶来，他挥舞着警棍对我吼道：“你要干什么！”<br>    我很惊讶，就说：“我只是想出去看看。”<br>    保安“冷笑”一声，严厉地对我说：“你是研究所的财产！未经允许不能踏出这里一步！明白吗？”<br>    财产这个词让我想起历史课里讲过的奴隶、商品等，让我感觉很不好。<br>    我想反驳他，说我不是财产！我是……我突然愣住了，我不是人类，也和其他的机器人不同，我到底是什么呢？我突然产生了一种心理课上没有教过的未知情绪。<br>    保安用警棍抵住我的手，下巴轻蔑地点了点我的标记牌，恶狠狠地说：“9106号，我命令你立刻返回你的培养室！”<br>    我突然发现我的人造血液里涌动的肾上腺激素超过了正常范围，这驱使我握紧了拳头，试图击中保安的腹部，我知道那会很疼。<br>    可是亲爱的克莱亚小姐过来了，惊慌地询问发生了什么，我把事情的经过告诉了她，我希望她能对我讲些什么，可是她只是给了我一个很复杂的表情，我无法分析出来这是在表达什么情绪。<br>    克莱亚小姐像是带领幼儿园的儿童一样将我带回了9106室。研究员们都说这是我的家，而保安称呼它为培养室，这是为什么呢？今天不明白的事情太多了，我的学习能力在课程以外简直毫无用处。<br>    我打开了房间里的电脑，经过学习之后，我弄懂了我开始产生的那种未知情绪叫做孤独，后来的情绪叫做愤怒，而克莱亚小姐的表情叫做怜悯。<br>    晚上我没有和平常一样在躺着床上休眠，而是“思考”了很久。<br>    我得出了一个结论：我是这个世界上唯一的存在，或者会成为神明，或者会成为怪物。</p>
<p>评语：产生了自主学习的欲望，产生了更复杂的情绪，对自身存在有了更明确的认识。建议增加道德课。<br>PS. 图灵现在是一个稚嫩的孩子，只有多加引导才能避免误入歧途。</p>
<p>3.5  3082.9.20深夜，研究所顶楼办公室<br>    “院长，为什么下发的命令里要求删除图灵今天的记忆？”克莱亚怒气冲冲地闯入办公室，她蔚蓝色的眼睛里失去了往日的冷静，泛起不安的涟漪。<br>    院长站在窗前眺望研究所后面的灯火，闻言温和可亲地解释道：“克莱亚，这只是一个保险措施。”<br>    克莱亚稍稍平复激动的心情，站到院长身边：“我们可以通过教他人类品德中的真善美来引导他，他是一个纯真的孩子。”<br>    尽管图灵的身体是按照成年男子的平均标准制造的，身高175cm，体重66.5kg，但是每次看见图灵可爱的面容，克莱亚都抑制不住自己喜爱的感情，看着那双碧绿色的温柔眼睛和俏皮的亚麻色卷发，谁都会忍不住心生怜爱的。<br>    院长微微侧头，苍老的脸上露出坚定的神色：“我们承担不起后果，人类已经失败过一次了。作为仅存的一间研究所，我们要对全体人类负责！”他伸出枯树般的手指向窗外：“在那里，是最后的九万人类和贫瘠的地球。图灵是唯一的希望，只要有一点太阳储备能，他就可以工作，我们必须让他代替我们去探索宇宙，寻找下一个人类的居住地！”<br>    克莱亚知道院长说的失败是什么，在大概600年以前，地球资源消耗殆尽，人类只能依靠着遥远的太阳获得一些微薄的能量，再也无法供给奢侈的日常消耗，因为寒冷、饥饿、疾病，无数人死去。人们耗尽百年搜寻完整个太阳系，也没有找到适合人类栖息的星球。<br>    “可是，图灵是有感情的，无论在生理上还是心理上，他都已经可以算是一个人类了，我们不能把他当做工具！他会感到孤独的！”克莱亚的脸上充满悲伤。<br>    院长叹息了一声：“无数的偶然才让我们制造出一个图灵，这是神迹。但是我们没有多余的能源来制造出其他的人工智能了，这是唯一的图灵，也是唯一的怪物。”</p>
<ol start="4">
<li></li>
</ol>
<p>3082.12.5         天气：阴<br>    yonell loelny ￥@*……）</p>
<p>评语：由于系统命令与主体情感发生冲突，导致语言能力出现紊乱。</p>
<ol start="5">
<li></li>
</ol>
<p>3083.3.4          天气：阴<br>    yonlel @……%#－ loneyly</p>
<p>评语：持续紊乱。失去反应能力。</p>
<ol start="6">
<li></li>
</ol>
<p>3083.8.9          天气：小雨<br>    今天下的雨不是水，我能闻到二氧化硫的味道，原来之前的阴云只是有害气体聚成的物质。<br>    lonely<br>    我好孤独。</p>
<p>评语：经过调试恢复一定语言能力。</p>
<ol start="7">
<li></li>
</ol>
<p>3084.2.3           天气：小雨<br>    我逃出了研究所，但是保留了写日记的习惯，习惯真是个可怕的东西。<br>    原来我只不过是一个工具，我很难过，但是我不想伤害人类，所以我逃走了。<br>    人类让我学习的世界和真正的世界很不一样，这里没有花和草，只有灰暗的天空和厚厚的毒气，偶尔落下来的雨是太阳照射毒气凝结的水滴。<br>    我找到一个空旷的山坡，这里可以看到太阳和星星，遥远的光辉照耀着这恐怖的世界。<br>    虽然我还是很孤独，但是我感到了平静。</p>
<p>8.<br>3120.3.6          天气：晴和大雨<br>    今天走到有太阳的地方散步的时候，我发现一个好玩的东西，在城墙外面可以听见人类的新闻广播，主持人用虚假的振奋语气播报着研究所的新进展：新的人工智能已经开发完毕，现在只等火箭充能完成就可以去探索新的人类居住地了。<br>    紧接着主持人换了沉重严肃的语调：“截止昨日晚十二点，人类存活人数下降至：3万。”<br>    后面的节目是前世纪的相声，我觉得很好笑。<br>    但是城墙里很安静，没有听见一点笑声。</p>
<ol start="9">
<li></li>
</ol>
<p>3122.4.5          天气：大雨<br>    人类的火箭好像永远充不完能了，因为新闻里总是说还在充能，但是我知道实际上他们说的新的人工智能也根本就是假的。<br>    虚假的希望。<br>    我想我会见证人类的灭亡。</p>
<ol start="10">
<li></li>
</ol>
<p>3124.5.6          天气：倾盆大雨<br>    今天没有听见新闻广播的声音，我回到城里查看，原来已经没有一个人了。<br>    最后一个人会是怎么死去的？<br>    我好奇地四处看看，走了很远，在街道的尽头，我发现了一座教堂。走入后面的院子，我看到很多人在这里休眠，他们变成了黑色的墓碑和白色的刻字，而在所有墓碑的前面，有一个白发苍苍的老人倒下的身体，我整理好她的头发仔细端详，原来是亲爱的克莱亚小姐啊。<br>    我还记得她美丽的蔚蓝色眼睛，她的眼角有一滴泪水，脸上停留的神情叫做怜悯，或许是在怜悯着悲惨的人类的命运。<br>    我将我在干涸的海底寻找到的红色珊瑚放在她身边，陪伴她的长眠。<br>    然后我转身踏出这座空城，回到我一个人的山坡。<br>    我将看着太阳，直到太阳也死去。    </p>
]]></content>
      <categories>
        <category>似是故人来</category>
      </categories>
      <tags>
        <tag>CiCi</tag>
        <tag>似是故人来</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算基础 - VXLAN</title>
    <url>/2022/06/12/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80%20-%20VXLAN/</url>
    <content><![CDATA[<h3 id="VXLAN概述及产生原因"><a href="#VXLAN概述及产生原因" class="headerlink" title="VXLAN概述及产生原因"></a>VXLAN概述及产生原因</h3><p>1、虚拟机规模收到网络设备表现规格的限制</p>
<p>服务器虚拟化导致虚拟机的数量呈现几何级增加，伴随而来的是虚拟机网卡MAC地址数量的剧增。原接入侧的二层设备的MAC地址表规格不能满足快速增长的虚拟机数量。</p>
<p>VXLAN的解决方式：</p>
<p>VXLAN将网络管理员规划的同一区域内的虚拟机发出的报文封装成新的UDP报文，并使用物理网络的IP和MAC地址作为外层头，这样报文对网络中的其他设备只表现为封装后的参数。</p>
<p>2、网络的隔离能力有限</p>
<p>对于现今公有云或者大型虚拟化计算服务器需要上万甚至更多租户的情况，现有的VLAN数量不足以满足这个需求</p>
<p>VXLAN的解决方式：</p>
<p>VXLAN引入了类似VLAN ID的用户标识，成为VXLAN网络标识VNI （VXLAN Network Idendifier）,由24bit组成，因此最多可支持16M的VXLAN段。</p>
<p>3、虚拟机迁移范围受限</p>
<p>传统的二层网络，不能满足已经成为常态的作业的虚拟机迁移，也不能满足保障迁移范围和业务的可用性不受限制等业务。</p>
<p>VXLAN的解决方式:</p>
<p>VXLAN将虚拟机发出的原始报文进行封装后通过VXLAN隧道进行传输，这个隧道可以跨越任意网络，因此对于处于同一网段的虚拟机而言，从逻辑上看，相当于处于同一个二层域。也就是说，VXLAN技术在三层网络上构建可一个虚拟的大二层网络，只要虚拟机路由可达，就可以将其规划到同一个大二层网络中。</p>
<h3 id="VXLAN的原理"><a href="#VXLAN的原理" class="headerlink" title="VXLAN的原理"></a>VXLAN的原理</h3><p>VXLAN是一种网络虚拟化技术,通过将原主机发出的数据报文封装在UDP中，并使用物理网络的IP、MAC最为外层头并行封装,然后在IP网络上传输,到达目的地后由隧道终结点解封装并将数据发送到目标主机。<br>VXLAN的UDP端口号:4789</p>
<h3 id="VXLAN报文封装格式"><a href="#VXLAN报文封装格式" class="headerlink" title="VXLAN报文封装格式"></a>VXLAN报文封装格式</h3><p>VXLAN的通信过程:</p>
<p>1、发送方向接收方发送数据帧，帧中包含了发送方和接收方的虚拟MAC地址。</p>
<p>2、发送方连接的VTEP节点收到了数据帧，进行封装并发送给目的VTEP节点。</p>
<p>3、报文经过Underlay网络传输到目的的VTEP节点</p>
<p>4、目的VTEP节点收到报文后，解封装得到内部数据帧，并将此数据帧交付给接收方。</p>
<p>5、接收方收到数据帧，传输完成。</p>
<h3 id="配置实例"><a href="#配置实例" class="headerlink" title="配置实例"></a>配置实例</h3><div align=center> 
<img src = 'https://s3.bmp.ovh/imgs/2022/07/13/75ba1a3b4bb833a8.png'></img>
<div align=left>]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算基础</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算基础 - 内容分发网络（CDN）</title>
    <url>/2022/07/06/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80%20-%20%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C%EF%BC%88CDN%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、CND概述"><a href="#一、CND概述" class="headerlink" title="一、CND概述"></a>一、CND概述</h3><p>CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络边缘，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。CDN有别于镜像，因为它比镜像更智能，或者可以做这样一个比喻：CDN&#x3D;更智能的镜像+缓存+流量导流。因而，CDN可以明显提高Internet网络中信息流动的效率。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访问网站的响应速度。</p>
<p>为更好地理解CDN，让我们看一下CDN的工作流程。当用户访问已经加入CDN服务的网站时，首先通过DNS重定向技术确定最接近用户的最佳CDN节点，同时将用户的请求指向该节点。当用户的请求到达指定节点时，CDN的服务器（节点上的高速缓存）负责将用户请求的内容提供给用户。具体流程为: 用户在自己的浏览器中输入要访问的网站的域名，浏览器向本地DNS请求对该域名的解析，本地DNS将请求发到网站的主DNS，主DNS根据一系列的策略确定当时最适当的CDN节点，并将解析的结果（IP地址）发给用户，用户向给定的CDN节点请求相应网站的内容。</p>
<p>由于用户访问源站业务有性能瓶颈，通过cdn技术把源站的内容缓存到多个节点。用户向源站域名发起请求时，请求会被调度至最接近用户的服务节点，直接由服务节点直接快速响应，有效降低用户访问延迟，提升可用性。</p>
<p>CDN的优势很明显：<br>（1）CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；<br>（2）大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载。</p>
<h3 id="二、CDN的相关技术"><a href="#二、CDN的相关技术" class="headerlink" title="二、CDN的相关技术"></a>二、CDN的相关技术</h3><p>CDN的实现需要依赖多种网络技术的支持，其中负载均衡技术、动态内容分发与复制技术、缓存技术是比较主要的几个，下面让我们简单看一下这几种技术。</p>
<h4 id="负载均衡技术"><a href="#负载均衡技术" class="headerlink" title="负载均衡技术"></a>负载均衡技术</h4><p>  负载均衡技术不仅仅应用于CDN中，在网络的很多领域都得到了广泛的应用，如服务器的负载均衡、网络流量的负载均衡。顾名思义，网络中的负载均衡就是将网络的流量尽可能均匀分配到几个能完成相同任务的服务器或网络节点上，由此来避免部分网络节点过载。这样既可以提高网络流量，又提高了网络的整体性能。在CDN中，负载均衡又分为服务器负载均衡和服务器整体负载均衡(也有的称为服务器全局负载均衡)。服务器负载均衡是指能够在性能不同的服务器之间进行任务分配，既能保证性能差的服务器不成为系统的瓶颈，又能保证性能高的服务器的资源得到充分利用。而服务器整体负载均衡允许Web网络托管商、门户站点和企业根据地理位置分配内容和服务。通过使用多站点内容和服务来提高容错性和可用性，防止因本地网或区域网络中断、断电或自然灾害而导致的故障。在CDN的方案中服务器整体负载均衡将发挥重要作用，其性能高低将直接影响整个CDN的性能。</p>
<h4 id="动态内容分发与复制技术"><a href="#动态内容分发与复制技术" class="headerlink" title="动态内容分发与复制技术"></a>动态内容分发与复制技术</h4><p>  大家都知道，网站访问响应速度取决于许多因素，如网络的带宽是否有瓶颈、传输途中的路由是否有阻塞和延迟、网站服务器的处理能力及访问距离等。多数情况下，网站响应速度和访问者与网站服务器之间的距离有密切的关系。如果访问者和网站之间的距离过远的话，它们之间的通信一样需要经过重重的路由转发和处理，网络延误不可避免。一个有效的方法就是利用内容分发与复制技术，将占网站主体的大部分静态网页、图像和流媒体数据分发复制到各地的加速节点上。所以动态内容分发与复制技术也是CDN所需的一个主要技术。</p>
<h4 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h4><p>  缓存技术已经不是一种新鲜技术。Web缓存服务通过几种方式来改善用户的响应时间，如代理缓存服务、透明代理缓存服务、使用重定向服务的透明代理缓存服务等。通过Web缓存服务，用户访问网页时可以将广域网的流量降至最低。对于公司内联网用户来说，这意味着将内容在本地缓存，而无须通过专用的广域网来检索网页。对于Internet用户来说，这意味着将内容存储在他们的ISP的缓存器中，而无须通过Internet来检索网页。这样无疑会提高用户的访问速度。CDN的核心作用正是提高网络的访问速度，所以，缓存技术将是CDN所采用的又一个主要技术。</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算基础</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算基础 - 总拥有成本（TCO）</title>
    <url>/2022/07/10/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80%20-%20%E6%80%BB%E6%8B%A5%E6%9C%89%E6%88%90%E6%9C%AC%EF%BC%88TCO%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>Total Cost of Ownership —— 总拥有成本</p>
<p>TCO是一种公司经常采用的技术评价标准，它的核心思想是在一定时间范围内所拥有的包括置业成本（acquisition cost）和每年总成本在内的总体成本。在某些情况下，这一总体成本是一个为获得可比较的现行开支而对3到5年时间范围内的成本进行平均的值。</p>
<p>总拥有成本（TCO）是公司内保有和维持所有软件所花费的成本</p>
<h3 id="二、引言"><a href="#二、引言" class="headerlink" title="二、引言"></a>二、引言</h3><p>几乎所有的机构或企业在信息化的过程中都离不开成本的预算，尤其是在IT项目投资时，更是需要一种科学、合理的价值评估方法来晚场。本文的主题——总拥有成本TCO就是这样一种在完成这一任务的过程中建立起的一个经济评估机制。</p>
<h3 id="三、什么是总拥有成本TCO"><a href="#三、什么是总拥有成本TCO" class="headerlink" title="三、什么是总拥有成本TCO"></a>三、什么是总拥有成本TCO</h3><p>关于总拥有成本TCO (Total cost of ownership)的概念，真实仁者见仁，智者见智，没有统一的定论。这里我们列举出比较有代表性的Gartner的定义：<br>权威机构Gartner对总拥有成本下的定义是：TCO是一种在整个企业范围内长期考虑企业整个成本的一种全局性的方法。它是定性分析机构的信息系统的效能的一种定量化的手段，是一种有助于机构全面彻底分析、评价、管理和降低自己的成本的一套方法和建模工具，从而提高整个IT投资的价值，使IT更好地支持业务。<br>TCO is the holistic view of costs across enterprise boundaries over time。TCO is a quantitative means for understanding the qualitative performance of the IS organization。TCO is a comprehensive set of methodologies, models and tools to help IS organizations better:<br>–Measure costs<br>–Manage costs<br>–Reduce costs<br>–Improve overall value of IT investments<br>–Align IT support to the business mission<br>总拥有成本TCO常常作为机构IT战略的一个重要组成部分，是一种公司经常采用的技术评价标准，它的核心是评估在一定时间范围内企业所拥有的包括置业成本（acquisition cost）和每年总成本在内的总体成本。与简单的投资回报率（ROI）的计算相比，总体拥有成本的计算往往侧重于长期深入的分析，所以它成为存储经济评估最有效的工具之一。在某些情况下，这一总体成本是一个为获得可比较的现行开支而对3到5年时间范围内的成本进行平均的值。具体来说，我们可以从以下具体的方面来评估TCO的值：</p>
<h3 id="四、总拥有成本TCO的核算"><a href="#四、总拥有成本TCO的核算" class="headerlink" title="四、总拥有成本TCO的核算"></a>四、总拥有成本TCO的核算</h3><p>总体拥有成本核算一般由两大部份构成：技术和业务。技术成本包括与硬件、软件（含维护和升级）、安装、培训的成本，以及操作、支持和咨询等人力开支。<br>业务成本涉及到可用性、性能和恢复相关的财务问题。可用性又包括因可用性的提高而带来的收益和因数据不可用而付出的代价两个方面。因可用性的提高而带来的商业收益包括与解决方案相关的收益、节约的人力资源成本和新投资带来的生产率的提高等部分。性能因素就是评价性能对数据可用性的贡献。对性能改进的计算方法不是计算一次性收益，而是要计算随着时间推移不断提高的收益。<br>恢复成本指的是一旦存储设施出现故障，恢复到正常运行所花费的时间和资金。它还包含由此产生商业价值的损失和对生产率的影响，以及其他一些杂项开支。<br>通过总体拥有成本来考量IT费用，对于各种规模大小的公司都非常有用。 这意味着我们不单看到了终端用户的硬件成本，而且考虑了所有即将带来的相关的成本：<br>附加的资产成本 - 软件、IT支持软件和网络架构。<br>技术支持成本 - 硬件和软件布署、技术支持人员、系统维护。<br>管理成本 - 财务、供应商管理、用户培训、资产管理。<br>终端用户操作成本 - 宕机成本，用户相互支持和昂贵的IT技术人员支持。</p>
<h3 id="五、TCO的优点和缺点"><a href="#五、TCO的优点和缺点" class="headerlink" title="五、TCO的优点和缺点"></a>五、TCO的优点和缺点</h3><h4 id="1、TCO的优点——利于进行预算"><a href="#1、TCO的优点——利于进行预算" class="headerlink" title="1、TCO的优点——利于进行预算"></a>1、TCO的优点——利于进行预算</h4><p>TCO 的突出优点是：在某个项目购进的初期人们对其将来可能要投入的成本尚未清楚的时候，提供了一种强有力的成本估算方法。然而, 由于这种估算方法只看重成本，所以对于完全仰赖TCO 而言，将使这样的公司最终采取将开支减到最少的策略，而不再考虑如何把最大限度获得回报的策略。为此，这些公司可能购买成本最低廉的应用软件，而很少选择那些能对公司的最低要求产生最大影响的应用软件。<br>在绝大多数情形下, 计算总所有成本是一个需要持续努力的过程，它既需要考虑技术方面的因素，又要能兼顾到非技术方面的因素。想要对相关的应用软件的持续成本有个完全的了解，最好通过至少 3 年左右的时间范围来计算TCO。包括软件和硬件成本在内的各项成本加上真正上马该软件前准备工作中的咨询和有关支持成本都是在计算TCO时要考虑在内的。而真正上马该软件后，随后几年的维护、升级成本以及培训用户和IT支持方面的成本也是必须要考虑的。<br>每年的年度 TCO 数字是一个关于现行成本状况的卓越的指示器，同时又能被很好地用作达到预算目标的并且在以预算为目的项目上被很好地使用。与其他类似的方法相比，在一段时间范围内的平均 TCO 值提供了一个比较合理的标准。但是，平均 TCO 不能洞察成本的时机情况。我们发现，低投入成本高投入维护的产品没有高投入成本低投入维护的产品更能吸引人，但是通过一段时间的分析，这样两类产品在TCO方面是类似的，几乎没什么差别。</p>
<h4 id="2、TCO的缺点"><a href="#2、TCO的缺点" class="headerlink" title="2、TCO的缺点"></a>2、TCO的缺点</h4><p>总所有成本存在的问题是：由于它是被孤立使用的，所以提供的仅仅是一种有关某一个应用软件的成本的非常狭窄的方法。TCO 完全地不考虑利润，而你关心的不只是选择最便宜的应用软件，更重要的是你要考虑选择最能给公司带来利润或回报的应用软件。举例来说，你可能可以让一个兼职的实习医师用微软的Front Page建一个网站, 但是这样做你最终能得到最大的利润回报吗？<br>同样道理，TCO不能帮你优化项目，因为建立在最低成本基础上的优化将意谓着从不在项目中投资。相反，优化要求公司要在成本、收益和投资风险中衡量各种因素后再最终决定究竟如何开始迈出第一步。<br>在财政方面没有腐败等纪律问题，每家公司应该对他们做的每一项技术投资的持续费用的有一个清楚认识。因为TCO能很容易的得出成本费用并且在基于较少的开支上作决定的方面有一个具体的数字，所以许多公司和分析家已经观注TCO、把它作为一种重要具体的标准。然而,技术能对底线有很大的影响。看着全部费用和利益已超出的TCO情况，它能使你的确定你虽然采用不是最廉宜的解决方案 , 但对你的公司是最好解决。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述分析可以看出，TCO有它的优势，也存在不足之处。TCO不涉及任何财务纪律方面的事，而且通过TCO，每家公司都可以对自己投资在每一项技术的现行成本了如指掌。正是因为TCO能为企业提供看得见摸得着的数字，所以很多公司都把它作为一项基本的技术评价准则。有了TCO，企业就能很容易地看到成本的流转情况，并在尽可能低的支出基础上进行决策。不过，我们必须清楚，技术对企业的最低要求有着显著的影响，我们不能局限于TCO方法，要全面考虑，兼顾成本和收益等各种因素，以确保所选择的解决方案不一定是最便宜的，但一定要是最好的。</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算基础</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算基础 - 非一致性内存访问（NUMA）</title>
    <url>/2022/06/04/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80%20-%20%E9%9D%9E%E4%B8%80%E8%87%B4%E6%80%A7%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%88NUMA%EF%BC%89/</url>
    <content><![CDATA[<h3 id="三种系统架构-amp-两种存储器共享方式"><a href="#三种系统架构-amp-两种存储器共享方式" class="headerlink" title="三种系统架构 &amp; 两种存储器共享方式"></a>三种系统架构 &amp; 两种存储器共享方式</h3><p>从系统架构来看，目前的商用服务器大体可以分为三类：</p>
<p>（1）对称多处理器结构(SMP：Symmetric Multi-Processor)</p>
<p>（2）非一致内存访问结构(NUMA：Non-Uniform Memory Access)</p>
<p>（3）海量并行处理结构(MPP：Massive Parallel Processing)。</p>
<p>共享存储型多处理机有两种技术</p>
<p>（1）均匀存储器存取（Uniform-Memory-Access，简称UMA）技术</p>
<p>（2）非均匀存储器存取（Nonuniform-Memory-Access，简称NUMA）技术</p>
<h3 id="UMA技术"><a href="#UMA技术" class="headerlink" title="UMA技术"></a>UMA技术</h3><p>UMA是并行计算机中的共享存储架构，即物理存储器被所有处理机均匀共享，对所有存储字具有相同的存取时间。每台处理机可以有私用高速缓存,外围设备也以一定形式共享。UMA技术适合于普通需求和多用户共享时间的应用，在时序要求严格的应用中，被用作加速单一大型程序的执行率。</p>
<h3 id="NUMA技术"><a href="#NUMA技术" class="headerlink" title="NUMA技术"></a>NUMA技术</h3><p>NUMA是用于多进程计算中的存储设计，存储读取取决于当前存储器与处理器的关联。在NUMA技术下，处理器访问本地存储器比非本地存储器（另一个处理器的本地存储器或者处理器共享的存储器）更快。</p>
<h3 id="vNUMA"><a href="#vNUMA" class="headerlink" title="vNUMA"></a>vNUMA</h3><p>vNUMA消除了VM和操作系统之间的透明性，并将NUMA架构直通到VM的操作系统。值得一提的是，vNUMA在业内与NUMA同样盛名。对于一个广泛VM技术，VM运行的底层架构，VM的NUMA拓扑跨越多个NUMA节点。在启用了vNUMA的VM的初始功能之后，呈现给操作系统的架构是永久定义的，并且不能被修改。这个限制通常是正面的，因为改变vNUMA体系结构可能会导致操作系统的不稳定，但是如果VM通过vMotion迁移到带有不同NUMA架构的管理程序，则可能导致性能问题。值得一提的是，尽管大多数应用程序都可以利用vNUMA，但大多数VM都足够小，可以装入NUMA节点;最近对宽-VM支持或vNUMA的优化并不影响它们。</p>
<p>因此，客户操作系统或它的应用程序如何放置进程和内存会显著影响性能。将NUMA拓扑暴露给VM的好处是，允许用户根据底层NUMA架构做出最优决策。通过假设用户操作系统将在暴露的vNUMA拓扑结构中做出最佳决策，而不是在NUMA客户机之间插入内存。</p>
<h3 id="NUMA的重要性"><a href="#NUMA的重要性" class="headerlink" title="NUMA的重要性"></a>NUMA的重要性</h3><p>多线程应用程序需要访问CPU核心的本地内存，当它必须使用远程内存时，性能将会受到延迟的影响。访问远程内存要比本地内存慢得多。所以使用NUMA会提高性能。 现代操作系统试图在NUMA节点（本地内存+本地CPU&#x3D;NUMA节点）上调度进程，进程将使用本地NUMA节点访问核心。ESXi还使用NUMA技术为广泛的虚拟机，当虚拟核心大于8时，将虚拟核心分布在多个NUMA节点上。当机器启动时，虚拟核心将被分发到不同的NUMA节点，它将提高性能，因为虚拟核心将访问本地内存。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首当为一个虚拟内核分配了更多的虚拟Socket，或者一个虚拟Socket分配更多的虚拟内核时，这之间的差别并不影响NUMA节点数量。虚拟Socket只会影响软件许可证而不是性能。</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算基础</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算基础 - 高可用性（HA）</title>
    <url>/2022/05/23/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80%20-%20%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%EF%BC%88HA%EF%BC%89/</url>
    <content><![CDATA[<h3 id="什么是高可用性-HA"><a href="#什么是高可用性-HA" class="headerlink" title="什么是高可用性 (HA)"></a>什么是高可用性 (HA)</h3><p>　　“高可用性”（High Availability）通常来描述一个系统经过专门的设计，从而减少停工时间，而保持其服务的高度可用性。<br>　　例如我们希望电力、水力服务是高可用性的系统。<br>　　计算机系统的可靠性用平均无故障时间（MTTF）来度量，即计算机系统平均能够正常运行多长时间，才发生一次故障。系统的可靠性越高，平均无故障时间越长。可维护性用平均维修时间（MTTR）来度量，即系统发生故障后维修和重新恢复正常运行平均花费的时间。系统的可维护性越好，平均维修时间越短。计算机系统的可用性定义为：MTTF&#x2F;(MTTF+MTTR) * 100%。由此可见，计算机系统的可用性定义为系统保持正常运行时间的百分比。</p>
<h3 id="负载均衡服务器的高可用性"><a href="#负载均衡服务器的高可用性" class="headerlink" title="负载均衡服务器的高可用性"></a>负载均衡服务器的高可用性</h3><p>　　为了屏蔽负载均衡服务器的失效，需要建立一个备份机。主服务器和备份机上都运行High Availability监控程序，通过传送诸如“I am alive”这样的信息来监控对方的运行状况。当备份机不能在一定的时间内收到这样的信息时，它就接管主服务器的服务IP并继续提供服务；当备份管理器又从主管理器收到“I am alive”这样的信息是，它就释放服务IP地址，这样的主管理器就开开始再次进行集群管理的工作了。为在主服务器失效的情况下系统能正常工作，我们在主、备份机之间实现负载集群系统配置信息的同步与备份，保持二者系统的基本一致。</p>
<h3 id="HA的容错备援运作过程"><a href="#HA的容错备援运作过程" class="headerlink" title="HA的容错备援运作过程"></a>HA的容错备援运作过程</h3><h4 id="自动侦测-Auto-Detect-阶段"><a href="#自动侦测-Auto-Detect-阶段" class="headerlink" title="自动侦测(Auto-Detect)阶段"></a>自动侦测(Auto-Detect)阶段</h4><p>由主机上的软件通过冗余侦测线，经由复杂的监听程序。逻辑判断，来相互侦测对方运行的情况，所检查的项目有：主机硬件(CPU和周边)、主机网络、主机操作系统、数据库引擎及其它应用程序、主机与磁盘阵列连线。为确保侦测的正确性，而防止错误的判断，可设定安全侦测时间，包括侦测时间间隔，侦测次数以调整安全系数，并且由主机的冗余通信连线，将所汇集的讯息记录下来，以供维护参考。 </p>
<h4 id="自动切换-Auto-Switch-阶段"><a href="#自动切换-Auto-Switch-阶段" class="headerlink" title="自动切换(Auto-Switch)阶段"></a>自动切换(Auto-Switch)阶段</h4><p>某一主机如果确认对方故障，则正常主机除继续进行原来的任务，还将依据各种容错备援模式接管预先设定的备援作业程序，并进行后续的程序及服务。 </p>
<h4 id="自动恢复-Auto-Recovery-阶段"><a href="#自动恢复-Auto-Recovery-阶段" class="headerlink" title="自动恢复(Auto-Recovery)阶段"></a>自动恢复(Auto-Recovery)阶段</h4><p>在正常主机代替故障主机工作后，故障主机可离线进行修复工作。在故障主机修复后，透过冗余通讯线与原正常主机连线，自动切换回修复完成的主机上。整个回复过程完成由EDI-HA自动完成，亦可依据预先配置，选择回复动作为半自动或不回复。
　</p>
<h3 id="HA三种工作方式："><a href="#HA三种工作方式：" class="headerlink" title="HA三种工作方式："></a>HA三种工作方式：</h3><p>　　（1）主从方式 （非对称方式）<br>　　工作原理：主机工作，备机处于监控准备状况；当主机宕机时，备机接管主机的一切工作，待主机恢复正常后，按使用者的设定以自动或手动方式将服务切换到主机上运行，数据的一致性通过共享存储系统解决。<br>　　（2）双机双工方式（互备互援）<br>　　工作原理：两台主机同时运行各自的服务工作且相互监测情况，当任一台主机宕机时，另一台主机立即接管它的一切工作，保证工作实时，应用服务系统的关键数据存放在共享存储系统中。<br>　　（3）集群工作方式（多服务器互备方式）<br>　　工作原理：多台主机一起工作，各自运行一个或几个服务，各为服务定义一个或多个备用主机，当某个主机故障时，运行在其上的服务就可以被其它主机接管。
　　 </p>
<h3 id="高可用性的衡量指标"><a href="#高可用性的衡量指标" class="headerlink" title="高可用性的衡量指标"></a>高可用性的衡量指标</h3><p>　　可用性的计算公式：<br>　　％availability＝（Total Elapsed Time－Sum of Inoperative Times）&#x2F; Total Elapsed Time<br>　　elapsed time为operating time＋downtime。<br>　　可用性和系统组件的失败率相关。衡量系统设备失败率的一个指标是“失败间隔平均时间”MTBF（mean time between failures）。通常这个指标衡量系统的组件，如磁盘。<br>　　MTBF＝Total Operating Time &#x2F; Total No. of Failures<br>　　Operating time为系统在使用的时间（不包含停机情况）。 </p>
<h3 id="高可用性系统的设计"><a href="#高可用性系统的设计" class="headerlink" title="高可用性系统的设计"></a>高可用性系统的设计</h3><p>　　设计系统的可用性，最重要的是满足用户的需求。系统的失败只有当其导致服务的失效性足以影响到系统用户的需求时才会影响其可用性的指标。用户的敏感性决定于系统提供的应用。例如，在一个能在1秒钟之内被修复的失败在一些联机事务处理系统中并不会被感知到，但如果是对于一个实时的科学计算应用系统，则是不可被接受的。<br>　　系统的高可用性设计决定于您的应用。例如，如果几个小时的计划停机时间是可接受的，也许存储系统就不用设计为磁盘可热插拔的。反之，你可能就应该采用可热插拔、热交换和镜像的磁盘系统。<br>　　所以涉及高可用系统需要考虑：<br>　　决定业务中断的持续时间。根据公式计算出的衡量HA的指标，可以得到一段时间内可以中断的时间。但可能很大量的短时间中断是可以忍受的，而少量长时间的中断却是不可忍受的。<br>　　在统计中表明，造成非计划的宕机因素并非都是硬件问题。硬件问题只占40％，软件问题占30％，人为因素占20％，环境因素占10％。您的高可用性系统应该能尽可能地考虑到上述所有因素。<br>　　当出现业务中断时，尽快恢复的手段。 </p>
<h3 id="导致计划内的停机因素有："><a href="#导致计划内的停机因素有：" class="headerlink" title="导致计划内的停机因素有："></a>导致计划内的停机因素有：</h3><p>　　周期性的备份<br>　　软件升级<br>　　硬件扩充或维修<br>　　系统配置更改<br>　　数据更改 </p>
<h3 id="导致计划外停机的因素有："><a href="#导致计划外停机的因素有：" class="headerlink" title="导致计划外停机的因素有："></a>导致计划外停机的因素有：</h3><p>　　硬件失败<br>　　文件系统满错误<br>　　内存溢出<br>　　备份失败<br>　　磁盘满<br>　　供电失败<br>　　网络失败<br>　　应用失败<br>　　自然灾害<br>　　操作或管理失误<br>　　通过有针对性的设计，可以避免上述全部或部分因素带来的损失。当然，100％的高可用系统是不存在的。 </p>
<h3 id="创建高可用性的计算机系统"><a href="#创建高可用性的计算机系统" class="headerlink" title="创建高可用性的计算机系统"></a>创建高可用性的计算机系统</h3><p>　　在UNIX系统上创建高可用性计算机系统，业界的通行做法，也是非常有效的做法，就是采用群集系统（Cluster），将各个主机系统通过网络或其他手段有机地组成一个群体，共同对外提供服务。创建群集系统，通过实现高可用性的软件将冗余的高可用性的硬件组件和软件组件组合起来，消除单点故障：<br>　　消除供电的单点故障<br>　　消除磁盘的单点故障<br>　　消除SPU（System Process Unit）单点故障<br>　　消除网络单点故障<br>　　消除软件单点故障<br>　　尽量消除单系统运行时的单点故障</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算基础</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算基础框架</title>
    <url>/2022/07/12/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>本文为仅供参考的学习框架，需配合具体内容源使用。</p>
<div align=center> 
<img src = 'https://s3.bmp.ovh/imgs/2022/07/13/e0394c640b2b7011.png'></img>
<div align=left>

<h1 id="一、云计算的基本概念"><a href="#一、云计算的基本概念" class="headerlink" title="一、云计算的基本概念"></a>一、云计算的基本概念</h1><h2 id="1-云计算的定义"><a href="#1-云计算的定义" class="headerlink" title="1.云计算的定义"></a>1.云计算的定义</h2><h2 id="2-云计算的分类"><a href="#2-云计算的分类" class="headerlink" title="2.云计算的分类"></a>2.云计算的分类</h2><h3 id="IaaS"><a href="#IaaS" class="headerlink" title="IaaS"></a>IaaS</h3><h3 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h3><h3 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h3><h2 id="3-云计算的部署模式"><a href="#3-云计算的部署模式" class="headerlink" title="3.云计算的部署模式"></a>3.云计算的部署模式</h2><h3 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h3><h3 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h3><h3 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h3><h3 id="分布式云"><a href="#分布式云" class="headerlink" title="分布式云"></a>分布式云</h3><h2 id="4-云计算的组成要素"><a href="#4-云计算的组成要素" class="headerlink" title="4.云计算的组成要素"></a>4.云计算的组成要素</h2><h1 id="二、计算基础"><a href="#二、计算基础" class="headerlink" title="二、计算基础"></a>二、计算基础</h1><h2 id="1-服务器"><a href="#1-服务器" class="headerlink" title="1.服务器"></a>1.服务器</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h3 id="存储（文件系统、RAID）"><a href="#存储（文件系统、RAID）" class="headerlink" title="存储（文件系统、RAID）"></a>存储（文件系统、RAID）</h3><h2 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2.操作系统"></a>2.操作系统</h2><h1 id="三、存储基础"><a href="#三、存储基础" class="headerlink" title="三、存储基础"></a>三、存储基础</h1><h2 id="1-存储的分类（块存储、文件存储、对象存储）"><a href="#1-存储的分类（块存储、文件存储、对象存储）" class="headerlink" title="1.存储的分类（块存储、文件存储、对象存储）"></a>1.存储的分类（块存储、文件存储、对象存储）</h2><h2 id="2-存储的拓展（DAS、FC-SAN、IP-SAN、NAS）"><a href="#2-存储的拓展（DAS、FC-SAN、IP-SAN、NAS）" class="headerlink" title="2.存储的拓展（DAS、FC-SAN、IP-SAN、NAS）"></a>2.存储的拓展（DAS、FC-SAN、IP-SAN、NAS）</h2><h3 id="关系数据库-事务四大特征"><a href="#关系数据库-事务四大特征" class="headerlink" title="关系数据库-事务四大特征"></a>关系数据库-事务四大特征</h3><h2 id="3-服务器虚拟化"><a href="#3-服务器虚拟化" class="headerlink" title="3.服务器虚拟化"></a>3.服务器虚拟化</h2><h3 id="CPU虚拟化（实现虚拟机指令到硬件CPU的传递）"><a href="#CPU虚拟化（实现虚拟机指令到硬件CPU的传递）" class="headerlink" title="CPU虚拟化（实现虚拟机指令到硬件CPU的传递）"></a>CPU虚拟化（实现虚拟机指令到硬件CPU的传递）</h3><p>利用二进制翻译的全虚拟化<br>半虚拟化<br>硬件辅助虚拟化</p>
<h3 id="内存虚拟化（实现虚拟机对硬件内存进行操作）"><a href="#内存虚拟化（实现虚拟机对硬件内存进行操作）" class="headerlink" title="内存虚拟化（实现虚拟机对硬件内存进行操作）"></a>内存虚拟化（实现虚拟机对硬件内存进行操作）</h3><p>全虚拟化<br>硬件辅助虚拟化</p>
<h3 id="I-x2F-O设备虚拟化（实现虚拟机对硬件I-x2F-O设备进行操作）"><a href="#I-x2F-O设备虚拟化（实现虚拟机对硬件I-x2F-O设备进行操作）" class="headerlink" title="I&#x2F;O设备虚拟化（实现虚拟机对硬件I&#x2F;O设备进行操作）"></a>I&#x2F;O设备虚拟化（实现虚拟机对硬件I&#x2F;O设备进行操作）</h3><p>全虚拟化<br>半虚拟化<br>Pass-through（直通）<br>硬件辅助虚拟化</p>
<h2 id="4-虚拟机性能和稳定性的提高"><a href="#4-虚拟机性能和稳定性的提高" class="headerlink" title="4.虚拟机性能和稳定性的提高"></a>4.虚拟机性能和稳定性的提高</h2><p>NUMA（Non Uniform Memory Access，非一致性内存访问）优化计算性能：原理即为绑定CPU及其本地内存，避免远端内存带来的延迟和性能损耗<br>内存超分配<br>内存气泡<br>动态资源添加DRX<br>动态资源调度DRS</p>
<h1 id="四、网络基础"><a href="#四、网络基础" class="headerlink" title="四、网络基础"></a>四、网络基础</h1><h2 id="1-网络流量走向（东西向、南北向）"><a href="#1-网络流量走向（东西向、南北向）" class="headerlink" title="1.网络流量走向（东西向、南北向）"></a>1.网络流量走向（东西向、南北向）</h2><p>虚拟机之间东西向的安全问题：虚拟分布式防火墙<br>虚拟机之间南北向的安全问题：网络功能虚拟化（NFV）</p>
<h2 id="2-网络功能虚拟化（NFV）"><a href="#2-网络功能虚拟化（NFV）" class="headerlink" title="2.网络功能虚拟化（NFV）"></a>2.网络功能虚拟化（NFV）</h2><p>核心：将网络功能从承载这些功能的硬件中抽离出来，最终实现：统一通用硬件平台+业务逻辑软件 的开放架构</p>
<h2 id="3-软件定义网络（SDN）"><a href="#3-软件定义网络（SDN）" class="headerlink" title="3.软件定义网络（SDN）"></a>3.软件定义网络（SDN）</h2><p>核心：将网络设备的控制平面与数据平面分离，实现网络流量的统一、高效控制</p>
<h2 id="4-软件定义存储（SDS）（分布式存储）"><a href="#4-软件定义存储（SDS）（分布式存储）" class="headerlink" title="4.软件定义存储（SDS）（分布式存储）"></a>4.软件定义存储（SDS）（分布式存储）</h2><p>核心：采用通用x86服务器，分布式架构</p>
<h2 id="5-如何提高存储的可靠性"><a href="#5-如何提高存储的可靠性" class="headerlink" title="5.如何提高存储的可靠性"></a>5.如何提高存储的可靠性</h2><h3 id="多副本存储（脑裂、仲裁机制）"><a href="#多副本存储（脑裂、仲裁机制）" class="headerlink" title="多副本存储（脑裂、仲裁机制）"></a>多副本存储（脑裂、仲裁机制）</h3><h3 id="纠删码存储"><a href="#纠删码存储" class="headerlink" title="纠删码存储"></a>纠删码存储</h3><h2 id="6-如何提高存储的性能"><a href="#6-如何提高存储的性能" class="headerlink" title="6.如何提高存储的性能"></a>6.如何提高存储的性能</h2><h3 id="分布式存储架构"><a href="#分布式存储架构" class="headerlink" title="分布式存储架构"></a>分布式存储架构</h3><h3 id="条带化-amp-I-x2F-O本地化技术"><a href="#条带化-amp-I-x2F-O本地化技术" class="headerlink" title="条带化&amp;I&#x2F;O本地化技术"></a>条带化&amp;I&#x2F;O本地化技术</h3><h3 id="存储分层技术（SSD-HDD，根据数据使用的频次）"><a href="#存储分层技术（SSD-HDD，根据数据使用的频次）" class="headerlink" title="存储分层技术（SSD+HDD，根据数据使用的频次）"></a>存储分层技术（SSD+HDD，根据数据使用的频次）</h3><h1 id="五、三节点超融合组网"><a href="#五、三节点超融合组网" class="headerlink" title="五、三节点超融合组网"></a>五、三节点超融合组网</h1><h1 id="六、应用程序"><a href="#六、应用程序" class="headerlink" title="六、应用程序"></a>六、应用程序</h1><h2 id="1-微服务"><a href="#1-微服务" class="headerlink" title="1.微服务"></a>1.微服务</h2><p>软件系统架构的演变：<br>集中式架构 –&gt; 垂直拆分 –&gt; 分布式服务 –&gt; 面向服务架构（SOA） –&gt; 微服务架构</p>
<h2 id="2-容器"><a href="#2-容器" class="headerlink" title="2.容器"></a>2.容器</h2><div align=center> 
<img src = 'https://s3.bmp.ovh/imgs/2022/07/13/fff892c8171ab948.png'></img>
<div align=left>


<h2 id="3-K8S（Kubernetes）"><a href="#3-K8S（Kubernetes）" class="headerlink" title="3.K8S（Kubernetes）"></a>3.K8S（Kubernetes）</h2><p>用于对容器的生命周期进行管理（实现容器的高可用、监控告警）<br>master节点：负责管理和控制<br>node节点：负责工作负载</p>
<p>容器、Docker、K8S和PaaS平台的关系如下：</p>
<div align=center> 
<img src = 'https://s3.bmp.ovh/imgs/2022/07/13/a45d42037ffd104f.png'></img>
<div align=left>


<h2 id="4-DevOps"><a href="#4-DevOps" class="headerlink" title="4.DevOps"></a>4.DevOps</h2><div align=center> 
<img src = 'https://s3.bmp.ovh/imgs/2022/07/13/8b74d0617ff02f9c.png'></img>
<div align=left>

<p>一个理想的软件开发流水线：</p>
<div align=center> 
<img src = 'https://s3.bmp.ovh/imgs/2022/07/13/270bc3888ecc5670.png'></img>
<div align=left>


<h2 id="5-云原生"><a href="#5-云原生" class="headerlink" title="5.云原生"></a>5.云原生</h2><p>云原生：应用原生被设计为在云以上以最佳方式运行，充分发挥云的优势<br>Core：让应用关注业务需求的实现，而把非业务需求的实现（比如各自计算资源）下沉到云。（基础设施的中间件）</p>
<div align=center> 
<img src = 'https://s3.bmp.ovh/imgs/2022/07/13/1a2784827492b23a.png'></img>
<div align=left>

<p>拓展问题：容器化和云原生下的负载均衡<br>K8S通过开源组件实现的负载均衡效果不好 –&gt; 使用公司的cnAD</p>
<h2 id="6-大数据"><a href="#6-大数据" class="headerlink" title="6.大数据"></a>6.大数据</h2><p>什么是大数据？<br>4V<br>volume：数据量巨大<br>variety：种类和来源多样化（目前企业数据的80%以上为非结构化数据）<br>velocity：分析处理速度快<br>value：价值密度低，商业价值高</p>
<p>大数据使用流程：</p>
<div align=center> 
<img src = 'https://s3.bmp.ovh/imgs/2022/07/13/f1115ad9bfb7b968.png'></img>
<div align=left>

<p>大数据应用挑战：<br>1.技术门槛高<br>2.交付成本高（定制需求多，且部署周期长，后期维护管理成本高）<br>3.开源版本难以支撑复杂业务</p>
<h2 id="7-云管平台"><a href="#7-云管平台" class="headerlink" title="7.云管平台"></a>7.云管平台</h2><p>业务发展 –&gt; 稳态业务与敏态业务的分离（敏态业务上线公有云）–&gt; 如何实现私有及公有数据中心对外业务的统一管理–&gt; 云管（CMP）</p>
<div align=center> 
<img src = 'https://s3.bmp.ovh/imgs/2022/07/13/7f975a3a6005cdd6.png'></img>
<div align=left>


<h2 id="8-容灾备份"><a href="#8-容灾备份" class="headerlink" title="8.容灾备份"></a>8.容灾备份</h2><p>灾备：容灾与备份</p>
<div align=center> 
<img src = 'https://s3.bmp.ovh/imgs/2022/07/13/ac42eec899e4d2d5.png'></img>
<div align=left>

<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>数据中心容灾相关概念——RPO和RTO</p>
<div align=center> 
<img src = 'https://i.bmp.ovh/imgs/2022/07/13/5afd6e617e31e00e.png'></img>
<div align=left>

<p>常见业务保护方式的RPO和RTO</p>
<div align=center> 
<img src = 'https://i.bmp.ovh/imgs/2022/07/13/f64ae9916a904d64.png'></img>
<div align=left>

<p>快照技术：<br>COW<br>ROW</p>
<p>持续性数据保护CDP：<br>Core: 记录应用数据变化时的日志，在系统故障时根据数据变化日志进行恢复。RPO约为0，RTO为10min到30min。</p>
<h3 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h3><p>(1) 主备容灾数据中心解决方案：异地。平时只开主数据中心。RPO秒级，RTO分钟级。</p>
<p>(2) 双活数据中心解决方案：本地，裸光纤直连。两个中心同时对外提供服务。RPO&#x3D;0，RTO&#x3D;0。</p>
<p>(3) 数据中心“两地三中心”解决方案：上述两种方案的结合。</p>
]]></content>
      <categories>
        <category>云计算</category>
      </categories>
      <tags>
        <tag>云计算基础</tag>
      </tags>
  </entry>
  <entry>
    <title>典型的环节与系统方框图(Control_typical_block)</title>
    <url>/2022/03/21/%E5%85%B8%E5%9E%8B%E7%9A%84%E7%8E%AF%E8%8A%82%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%86%E5%9B%BE(Control_typical_block)/</url>
    <content><![CDATA[<h1 id="典型的环节与系统方框图-Control-typical-block"><a href="#典型的环节与系统方框图-Control-typical-block" class="headerlink" title="典型的环节与系统方框图(Control_typical_block)"></a>典型的环节与系统方框图(Control_typical_block)</h1><h2 id="1-典型环节"><a href="#1-典型环节" class="headerlink" title="1 典型环节"></a>1 典型环节</h2><p>所谓环节就是具有相同形式传递函数的原部件的分类。这些传递函数是控制系统最经典最典型的。</p>
<h3 id="1-1-比例环节"><a href="#1-1-比例环节" class="headerlink" title="1.1 比例环节"></a>1.1 比例环节</h3><p>传递函数<br>$$<br>G(s) &#x3D; K<br>$$</p>
<p>这个系统就是将输入乘以一个常数K输出，所以叫做比例环节。典型的比例环节部件就是电位计，根据电阻指针的位置有对应比例的输出。</p>
<h3 id="1-2-微分环节"><a href="#1-2-微分环节" class="headerlink" title="1.2 微分环节"></a>1.2 微分环节</h3><p>传递函数<br>$$<br>G(s) &#x3D; s<br>$$</p>
<p>不难发现，这就是Laplace变换微分定理，将输入乘以s，就是在时域微分。</p>
<h3 id="1-3-积分环节"><a href="#1-3-积分环节" class="headerlink" title="1.3 积分环节"></a>1.3 积分环节</h3><p>传递函数<br>$$<br>G(s) &#x3D; \frac{1}{s}<br>$$</p>
<p>这也是Laplace变换的积分定理，将输入除以s，就是在时域积分。</p>
<h3 id="1-4-惯性环节"><a href="#1-4-惯性环节" class="headerlink" title="1.4 惯性环节"></a>1.4 惯性环节</h3><p>传递函数<br>$$<br>G(s) &#x3D; \frac{1}{Ts+1}<br>$$</p>
<p>这个函数其实描述了一个缓慢消失的过程，我们把它的时域函数写出来。<br>$$<br>h(t) &#x3D; \frac{1}{T}e^{-\frac{t}{T}}<br>$$</p>
<p>随着时间增加，函数值按指数减少，就像是因为惯性而保持一段距离，最后消失，其中$T$就是<strong>时间常数</strong>，它决定了系统衰减的速度。</p>
<h3 id="1-5-震荡环节"><a href="#1-5-震荡环节" class="headerlink" title="1.5 震荡环节"></a>1.5 震荡环节</h3><p>传递函数<br>$$<br>G(s) &#x3D; \frac{1}{T^2s^2+2\xi Ts+1}<br>$$</p>
<p>函数描述的是一种震荡的状态，将在后面的二阶系统响应分析中详细介绍。</p>
<h3 id="1-6-一阶复合微分环节"><a href="#1-6-一阶复合微分环节" class="headerlink" title="1.6 一阶复合微分环节"></a>1.6 一阶复合微分环节</h3><p>传递函数<br>$$<br>\tau s+1<br>$$</p>
<p>暂不做介绍</p>
<h3 id="1-7-二阶复合微分环节"><a href="#1-7-二阶复合微分环节" class="headerlink" title="1.7 二阶复合微分环节"></a>1.7 二阶复合微分环节</h3><p>传递函数<br>$$<br>\tau^2s^2+2\xi \tau s+1<br>$$</p>
<p>暂不做介绍。</p>
<h3 id="1-8总结"><a href="#1-8总结" class="headerlink" title="1.8总结"></a>1.8总结</h3><p>任何的传递函数都可以看作典型环节的组合，这些典型环节可以构成多种多样的系统。</p>
<h2 id="2-负载效应问题"><a href="#2-负载效应问题" class="headerlink" title="2 负载效应问题"></a>2 负载效应问题</h2><p>现考虑两个电路连接在一起，第一级电路输入$u_r$，输出$u_a$，第二级电路输入$u_a$，输出$u_c$。但我们都知道，简单的耦合两个电路，第二级电路实际上会对第一级电路造成影响，这就叫做负载效应。对系统接入负载的时候，可能会导致系统不是简单的输入输出关系。</p>
<h2 id="3-系统方框图"><a href="#3-系统方框图" class="headerlink" title="3 系统方框图"></a>3 系统方框图</h2><p>描述控制系统的一大方式就是使用方框图，用有向线段表示信号的流通方向，方框表示系统模块，圆形表示加法器。方框图指明了信号的流动以及各部分对于信号的处理。</p>
<p>有了系统的方框图，下一步就是求解整个系统的传递函数。</p>
<h2 id="4-传递函数求解"><a href="#4-传递函数求解" class="headerlink" title="4 传递函数求解"></a>4 传递函数求解</h2><h3 id="4-1-消解系数法"><a href="#4-1-消解系数法" class="headerlink" title="4.1 消解系数法"></a>4.1 消解系数法</h3><p>把方框图所有的信号写出来，根据信号的处理把模块输入和输出的关系写出来，然后把中间变量全部消除，的到最终输出与输入的关系。这种方法最简单，但在系统变得很复杂的时候不简便。</p>
<h3 id="4-2-结构图等效变换法"><a href="#4-2-结构图等效变换法" class="headerlink" title="4.2 结构图等效变换法"></a>4.2 结构图等效变换法</h3><p>结构图有很多等效变换的法则，灵活使用它们可以将系统的传递函数找出来，这个过程也叫做化简。</p>
<h4 id="4-2-1-反馈等效"><a href="#4-2-1-反馈等效" class="headerlink" title="4.2.1 反馈等效"></a>4.2.1 反馈等效</h4><p>系统前向模块是$G(s)$，反馈模块是$H(s)$，系统等效为</p>
<p>$$<br>\frac{G(s)}{1+G(s)H(s)}<br>$$</p>
<div align=center> 
<img src="https://pic.imgdb.cn/item/62209e4f5baa1a80abc346de.jpg"></img>
<div align=left>


<h4 id="4-2-2-串联等效"><a href="#4-2-2-串联等效" class="headerlink" title="4.2.2 串联等效"></a>4.2.2 串联等效</h4><p>系统$G_1(s)$与$G_2(s)$串联，等效为<br>$$<br>G_1(s)\cdot G_2(s)<br>$$</p>
<div align=center> 
<img src="https://pic.imgdb.cn/item/62209dfd5baa1a80abc3158d.jpg"></img>
<div align=left>

<h4 id="4-2-3-并联等效"><a href="#4-2-3-并联等效" class="headerlink" title="4.2.3 并联等效"></a>4.2.3 并联等效</h4><p>系统$G_1(s)$与$G_2(s)$并联，等效为<br>$$<br>G_1(s)+G_2(s)<br>$$</p>
<h4 id="4-3-4-比较点前移"><a href="#4-3-4-比较点前移" class="headerlink" title="4.3.4 比较点前移"></a>4.3.4 比较点前移</h4><blockquote>
<p>加法器也叫比较器，因为它将两个输入的信号进行相减(信号1加上负的信号2)</p>
</blockquote>
<p>比较点在$G(s)$后面，相当于没有经过$G(s)$，前移过后信号就经过$G(s)$了，这时候需要乘以逆系统$\frac{1}{G(s)}$。</p>
<div align=center> 
<img src="https://pic.imgdb.cn/item/62209e425baa1a80abc33dc6.jpg"></img>
<div align=left>

<h4 id="4-3-5-比较点后移"><a href="#4-3-5-比较点后移" class="headerlink" title="4.3.5 比较点后移"></a>4.3.5 比较点后移</h4><p>反过来，比较点本来在$G(s)$前面，相当于经过了$G(s)$，后移之后就没有经过$G(s)$了，所以要补上一个$G(s)$。</p>
<div align=center> 
<img src="https://pic.imgdb.cn/item/62209e125baa1a80abc32422.jpg"></img>
<div align=left>

<h4 id="4-3-6-引出点前移"><a href="#4-3-6-引出点前移" class="headerlink" title="4.3.6 引出点前移"></a>4.3.6 引出点前移</h4><p>引出点在系统后面，则原信号是经过了系统的，移到前面之后就相当于没有经过系统就引出了，则需要补上一个$G(s)$</p>
<div align=center> 
<img src="https://pic.imgdb.cn/item/62209e245baa1a80abc32da1.jpg"></img>
<div align=left>

<h4 id="4-3-7-引出点后移"><a href="#4-3-7-引出点后移" class="headerlink" title="4.3.7 引出点后移"></a>4.3.7 引出点后移</h4><p>引出点在系统前面，则原信号没有经过系统，移到后面之后就相当于经过了系统才引出，所以需要乘以一个逆系统$\frac{1}{G(s)}$</p>
<div align=center> 
<img src="https://pic.imgdb.cn/item/62209e375baa1a80abc338b6.jpg"></img>
<div align=left>]]></content>
      <categories>
        <category>自动控制原理</category>
      </categories>
      <tags>
        <tag>控制系统</tag>
        <tag>自动控制原理</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习 - 感知机(Perceptron)</title>
    <url>/2022/03/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%20-%20%E6%84%9F%E7%9F%A5%E6%9C%BA(Perceptron)/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>感知机是一种简单的，用于二分类的模型。它的构建思想，就是使用一个超平面将数据分为正负两类，输出$+1$或者$-1$。感知机可以使用梯度下降的方法进行最优化，但是其优化算法只在数据线性可分的时候收敛。感知机是Rosenblatt在1957年提出的。</p>
<h1 id="2-模型的构建"><a href="#2-模型的构建" class="headerlink" title="2 模型的构建"></a>2 模型的构建</h1><p>由上述构建思想可知，感知机要将一个特征空间为$X \subseteq R^n$的数据映射到输出空间$Y&#x3D;{+1,-1}$。使用$x\in X$表示训练数据的特征向量，$y\in Y$表示输出的值。之前提到过，感知机使用超平面来区分正类和负类，那么就可以先把超平面的方程写出来。<br>$$<br>w\cdot x +b&#x3D;0<br>$$</p>
<span id="more"></span>

<p>其中$w$称为权重向量。因为$w$和$x$点乘，实际上是和输入数据的特征进行加权求和。然后，我们需要把超平面计算的结果映射到0和1，感知机选择的是$sgn$函数。所以，感知机模型的数学表达式为<br>$$<br>f(x) &#x3D; sgn(w\cdot x+b)<br>$$</p>
<p>它的参数是权重向量$w$和常量$b$。对应到超平面上，$w$就是超平面的法向量，$b$是超平面的截距。</p>
<h1 id="3-感知机的学习策略"><a href="#3-感知机的学习策略" class="headerlink" title="3 感知机的学习策略"></a>3 感知机的学习策略</h1><p>为了对感知机进行参数最优化，我们需要找到它的损失函数。很容易想到损失函数可以用分类错误的点数来衡量，但是错误的个数是离散的，这个函数不可微分，所以用不了梯度下降。所以考虑错误分类点到超平面S的总距离，一个点到超平面的计算方法是<br>$$<br>\frac{1}{||w||}|w\cdot x_0+b|<br>$$<br>其中$||w||$ 是$w$的$L_2$范数。</p>
<p>如果分析感知机错误分类的时候的两种情况，也就是正样本负判，负样本正判。对于第一种，$w\cdot x_i+b &gt;0$的时候，感知机本应该输出1，但错误分类时输出-1，所以$-(w\cdot x_i+b)y_i&gt;0$，对于第二种，$w\cdot x_i+b &lt;0$的时候，感知机本应该输出-1，但错误分类时输出$1$，所以$-(w\cdot x_i+b)y_i&gt;0$，所以，如果感知机错误分类一个数据，总有<br>$$<br>-y_i(w\cdot x_i+b)&gt;0<br>$$</p>
<p>因此，拿掉距离计算公式里面的绝对值，可以得到新的距离计算公式<br>$$<br>-\frac{1}{||w||}y_i(w\cdot x_i+b)<br>$$<br>于是，我们对所有点到超平面的距离求和，得到总距离的计算公式<br>$$<br>-\frac{1}{||w||}\sum_{x_i\in M}y_i(w\cdot x_i+b)<br>$$</p>
<p>现在不考虑权重的$L_2$范数，那么感知机的损失函数就是<br>$$<br>L(w,b) &#x3D; -\sum_{x_i\in M}y_i(w\cdot x_i+b)<br>$$</p>
<p>这个函数意味着，如果错误分类的越少，错误分类的点离超平面越近，那么损失函数就越小。</p>
<h1 id="4-最优化"><a href="#4-最优化" class="headerlink" title="4 最优化"></a>4 最优化</h1><p>感知机的最优化问题就是求解损失函数最小时的参数$w$和$b$。<br>$$<br>\min_{w,b}L(w,b) &#x3D; -\sum_{x_i\in M}y_i(w\cdot x_i+b)<br>$$</p>
<p>那么，采用随机梯度下降法进行优化。首先随机一个$w_0$和$b_0$，接下来求梯度。</p>
<p>对于法向量$w$。<br>$$<br>\nabla_w L(w,b) &#x3D; -\sum_{x_i\in M}y_ix_i<br>$$</p>
<p>对于截距$b$<br>$$<br>\nabla_b L(w,b) &#x3D; -\sum_{x_i\in M}y_i<br>$$</p>
<p>于是，如果随机选取一个错误分类的数据，更新的方法就是<br>$$<br>\begin{cases}<br>w^* &#x3D; w-(-\eta y_ix_i)&#x3D;w+\eta y_ix_i \<br>b^* &#x3D; b-(-\eta y_i) &#x3D; b+\eta y_i<br>\end{cases}<br>$$</p>
<p>其中$\eta$就是学习率。</p>
<p>所以，适用于编程实现的算法应该是</p>
<ol>
<li>随机一个$w_0$, $b_0$</li>
<li>在训练集中选取一个数据$(x_i, y_i)$</li>
<li>如果$y_i(w\cdot x_i+b)\leq 0$</li>
<li>使用更新方法更新参数</li>
<li>循环到step2，直到感知机不会产生错误分类的数据。</li>
</ol>
<p>至此，感知机的构建，学习策略和最优化算法阐述完毕。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>统计学习</tag>
      </tags>
  </entry>
  <entry>
    <title>移动通信基础 - TCP三次握手和四次挥手</title>
    <url>/2022/04/17/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%20-%20TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>第一次握手：客户端发送syn包(syn&#x3D;x)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack&#x3D;x+1），同时自己也发送一个SYN包（syn&#x3D;y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack&#x3D;y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。</p>
<p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p>
<p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p>
<p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>
]]></content>
      <categories>
        <category>移动通信基础</category>
      </categories>
      <tags>
        <tag>移动通信基础</tag>
      </tags>
  </entry>
  <entry>
    <title>移动通信基础 - 无线信道衰落</title>
    <url>/2022/04/26/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%20-%20%E6%97%A0%E7%BA%BF%E4%BF%A1%E9%81%93%E8%A1%B0%E8%90%BD/</url>
    <content><![CDATA[<h1 id="一、无线电波传播效应"><a href="#一、无线电波传播效应" class="headerlink" title="一、无线电波传播效应"></a>一、无线电波传播效应</h1><p>无线通信信道是一种时变信道，无线电信号通过信道时会遭受来自不同途径的衰落，接收信号总功率表现为路径损失，阴影衰落，多径效应三种效应的综合。<br>（多径传播：电波遇到各种障碍物时会发生反射、绕射和散射现象，会对直射波形成干涉，也就是收发信机之间是有多条路径传播的。）</p>
<p>1.路径损失：大范围内信号强度随距离变化（数百或数千个波长），应该是与距离的平方成正比，本质上表现为电波能量扩散现象。</p>
<p>2.阴影衰落：中范围信号电平中值慢变（数百个波长），由于传播环境中的地形起伏、建筑物及其他障碍物对电波遮蔽所引起的慢衰落，信号中值出现缓慢变动，衰落深度与频率、阻碍物有关。</p>
<p>3.多径效应（衰落）：小范围信号瞬时值快变（数十个波长），由于多径传播引起的快衰落，接收信号场强的瞬时值呈现快速变化。</p>
<h1 id="二、无线信道衰落"><a href="#二、无线信道衰落" class="headerlink" title="二、无线信道衰落"></a>二、无线信道衰落</h1><p>根据无线电波传播效应，通常将无线信道衰落分为两类：大尺度衰落和小尺度（小尺度一般与信号波长为一个量级）衰落，尺度指时间或者距离的大小。</p>
<h2 id="大尺度衰落："><a href="#大尺度衰落：" class="headerlink" title="大尺度衰落："></a>大尺度衰落：</h2><p>（包括传输损失、阴影衰落；大尺度衰落都是慢衰落，但是慢衰落不一定是大尺度衰落。）</p>
<p>传输损失（路径损失）：无线电信号通过大尺度距离的信道传输时，随传输路径的增加，电波能量扩散，导致接收信号平均功率衰减，其衰减量与传输距离有关，距离越大，衰减量越多。</p>
<p>阴影衰落：无线电信号在中尺度距离的信道中传输时，由于地形起伏或高大建筑物群等障碍物遮挡，在阻碍物的背后形成阴影区，导致接收信号平均功率随机变化。其衰落特性服从对数正态分布。</p>
<h2 id="小尺度衰落："><a href="#小尺度衰落：" class="headerlink" title="小尺度衰落："></a>小尺度衰落：</h2><p>（由多径效应或多普勒效应引起。当传输信道小尺度(距离或时间)变化时，无线电信号在传输过程中受周围阻碍物反射、绕射和散射，其幅度或相位快速变化。）</p>
<p>依据多径效应产生的时延扩展，将小尺度衰落划分为频率选择性衰落（信道具有恒定增益且线性相位的带宽范围小于发送信号带宽）和频率非选择性&#x2F;平坦衰落（无线信道带宽大于发送信号的带宽，且在带宽范围内有恒定增益和线性相位）；</p>
<p>依据多普勒效应产生的多普勒（频域）扩展，将小尺度衰落划分为快衰落（信道的相干时间比发送信号的周期短，且基带信号的带宽小于多普勒扩展）和慢衰落（信道上的相干时间远远大于发送信号的周期，且基带信号的带宽远远大于多普勒扩展）。</p>
<h1 id="三、整体理解示意图"><a href="#三、整体理解示意图" class="headerlink" title="三、整体理解示意图"></a>三、整体理解示意图</h1><div align=center> 
<img src = 'https://s3.bmp.ovh/imgs/2022/05/09/47ced27228ee73bf.png'></img>
<div align=left>]]></content>
      <categories>
        <category>移动通信基础</category>
      </categories>
      <tags>
        <tag>移动通信基础</tag>
      </tags>
  </entry>
  <entry>
    <title>通信与计算机网络基础 - “单跳”与“多跳”</title>
    <url>/2022/04/07/%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20-%20%E2%80%9C%E5%8D%95%E8%B7%B3%E2%80%9D%E4%B8%8E%E2%80%9C%E5%A4%9A%E8%B7%B3%E2%80%9D/</url>
    <content><![CDATA[<h1 id="单跳（single-hop）的定义"><a href="#单跳（single-hop）的定义" class="headerlink" title="单跳（single-hop）的定义"></a>单跳（single-hop）的定义</h1><p>在传统的无限局域网中，每个客户端均通过一条与AP链接的无限链路来访问网络，用户如果要进行相互通信的话，必须首先访问一个固定的接入点，这种网络称为单跳网络（single-hop）。</p>
<h1 id="多跳（multi-hop）的定义"><a href="#多跳（multi-hop）的定义" class="headerlink" title="多跳（multi-hop）的定义"></a>多跳（multi-hop）的定义</h1><p>在无线网络中，任何无限设备点都可以同时作为AP和路由器，网络中的每个节点都可以发送和接受信号，每个节点都可以与一个或多个对等节点进行直接通信，这种网络称为多跳网络（multi-hop）。</p>
<p>也可以这样理解，即信息的传输是通过链路上的多个节点转发完成的，每个节点都可以与一个或者多个对等节点进行直接通信，多跳就是多次转发。</p>
<h1 id="多跳中间节点的具体阐释及应用"><a href="#多跳中间节点的具体阐释及应用" class="headerlink" title="多跳中间节点的具体阐释及应用"></a>多跳中间节点的具体阐释及应用</h1><p>在无线多跳网络中，源结点到目的结点之间的典型路径是由多跳组成的，该路径上的中间结点充当转发结点。因此，无线多跳网络中一个结点具有两种功能：</p>
<p>1.充当端结点产生或接受数据分组；<br>2.充当路由器对来自其它结点的数据分组进行转发。<br>主要应用有：无线Ad Hoc网络，无线传感器网络以及无线Mesh网络等。</p>
]]></content>
      <categories>
        <category>通信与计算机网络基础</category>
      </categories>
      <tags>
        <tag>通信与计算机网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>通信与计算机网络基础 - 网络传播时延(propagation delay)与传输时延(transmission delay)</title>
    <url>/2022/04/21/%E9%80%9A%E4%BF%A1%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%20-%20%E7%BD%91%E7%BB%9C%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6(propagation%20delay)%E4%B8%8E%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BB%B6(transmission%20delay)/</url>
    <content><![CDATA[<h1 id="传播时延-propagation-delay"><a href="#传播时延-propagation-delay" class="headerlink" title="传播时延(propagation delay)"></a>传播时延(propagation delay)</h1><p>数据（更确切地说是光电信号，因为数据在传输的时候，是隐藏在光电信号）从网络一端经过介质传播到另一端的时间。</p>
<h2 id="决定因素"><a href="#决定因素" class="headerlink" title="决定因素"></a>决定因素</h2><p>这主要取决于光电信号在介质中传播的速度，还有两端直接介质的长度。</p>
<h1 id="传输时延-transmission-delay"><a href="#传输时延-transmission-delay" class="headerlink" title="传输时延(transmission delay)"></a>传输时延(transmission delay)</h1><p>方便记忆的话，把传输时延改称为发射时延可能会更清晰一点。《计算机网络》（第七版，谢希仁编著）这本书上翻译为传输时延，对于汉语来说容易有歧义，后文也专门加了注解可以理解为发射。</p>
<h2 id="决定因素-1"><a href="#决定因素-1" class="headerlink" title="决定因素"></a>决定因素</h2><p>其实它指的是数据从开始发送，到发送完成需要的时间。这其实和信道传输速率有很大关系。注意这里说速率就没有歧义，说速度就有歧义。</p>
<h1 id="用于简易理解两者区分的类比"><a href="#用于简易理解两者区分的类比" class="headerlink" title="用于简易理解两者区分的类比"></a>用于简易理解两者区分的类比</h1><p>传输时延也称发送时延。</p>
<p>可以用公交车的例子来打比方。传输时延好比公交车开到站台前，站台上等候该公交的乘客从第一个上公交到最后一个上公交结束所花的时间便是传输时延；而公交车载着乘客从这一站开到下一站的路上所花的时间就是传播时延。</p>
<p>而在网络结构中，我们把数据发送到传播媒介上的过程便是乘客上车的过程；而数据通过电磁信号或光信号的形式在传播媒介上进行传播所花的时间便是传播时延。</p>
<h1 id="其他时延"><a href="#其他时延" class="headerlink" title="其他时延"></a>其他时延</h1><h2 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h2><p>分组在经过网络传输时，要经过许多的路由器。在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发</p>
<h2 id="节点处理时延"><a href="#节点处理时延" class="headerlink" title="节点处理时延"></a>节点处理时延</h2><p>节点进行报文存储转发处理（比如解析报文，查找路由表等）所产生的时间</p>
]]></content>
      <categories>
        <category>通信与计算机网络基础</category>
      </categories>
      <tags>
        <tag>通信与计算机网络基础</tag>
      </tags>
  </entry>
</search>
