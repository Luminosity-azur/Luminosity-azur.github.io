<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>感知机(Perceptron)</title>
    <url>/2022/03/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%84%9F%E7%9F%A5%E6%9C%BA(Perceptron)/</url>
    <content><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>感知机是一种简单的，用于二分类的模型。它的构建思想，就是使用一个超平面将数据分为正负两类，输出$+1$或者$-1$。感知机可以使用梯度下降的方法进行最优化，但是其优化算法只在数据线性可分的时候收敛。感知机是Rosenblatt在1957年提出的。</p>
<h1 id="2-模型的构建"><a href="#2-模型的构建" class="headerlink" title="2 模型的构建"></a>2 模型的构建</h1><p>由上述构建思想可知，感知机要将一个特征空间为$X \subseteq R^n$的数据映射到输出空间$Y&#x3D;{+1,-1}$。使用$x\in X$表示训练数据的特征向量，$y\in Y$表示输出的值。之前提到过，感知机使用超平面来区分正类和负类，那么就可以先把超平面的方程写出来。<br>$$<br>w\cdot x +b&#x3D;0<br>$$</p>
<span id="more"></span>

<p>其中$w$称为权重向量。因为$w$和$x$点乘，实际上是和输入数据的特征进行加权求和。然后，我们需要把超平面计算的结果映射到0和1，感知机选择的是$sgn$函数。所以，感知机模型的数学表达式为<br>$$<br>f(x) &#x3D; sgn(w\cdot x+b)<br>$$</p>
<p>它的参数是权重向量$w$和常量$b$。对应到超平面上，$w$就是超平面的法向量，$b$是超平面的截距。</p>
<h1 id="3-感知机的学习策略"><a href="#3-感知机的学习策略" class="headerlink" title="3 感知机的学习策略"></a>3 感知机的学习策略</h1><p>为了对感知机进行参数最优化，我们需要找到它的损失函数。很容易想到损失函数可以用分类错误的点数来衡量，但是错误的个数是离散的，这个函数不可微分，所以用不了梯度下降。所以考虑错误分类点到超平面S的总距离，一个点到超平面的计算方法是<br>$$<br>\frac{1}{||w||}|w\cdot x_0+b|<br>$$<br>其中$||w||$ 是$w$的$L_2$范数。</p>
<p>如果分析感知机错误分类的时候的两种情况，也就是正样本负判，负样本正判。对于第一种，$w\cdot x_i+b &gt;0$的时候，感知机本应该输出1，但错误分类时输出-1，所以$-(w\cdot x_i+b)y_i&gt;0$，对于第二种，$w\cdot x_i+b &lt;0$的时候，感知机本应该输出-1，但错误分类时输出$1$，所以$-(w\cdot x_i+b)y_i&gt;0$，所以，如果感知机错误分类一个数据，总有<br>$$<br>-y_i(w\cdot x_i+b)&gt;0<br>$$</p>
<p>因此，拿掉距离计算公式里面的绝对值，可以得到新的距离计算公式<br>$$<br>-\frac{1}{||w||}y_i(w\cdot x_i+b)<br>$$<br>于是，我们对所有点到超平面的距离求和，得到总距离的计算公式<br>$$<br>-\frac{1}{||w||}\sum_{x_i\in M}y_i(w\cdot x_i+b)<br>$$</p>
<p>现在不考虑权重的$L_2$范数，那么感知机的损失函数就是<br>$$<br>L(w,b) &#x3D; -\sum_{x_i\in M}y_i(w\cdot x_i+b)<br>$$</p>
<p>这个函数意味着，如果错误分类的越少，错误分类的点离超平面越近，那么损失函数就越小。</p>
<h1 id="4-最优化"><a href="#4-最优化" class="headerlink" title="4 最优化"></a>4 最优化</h1><p>感知机的最优化问题就是求解损失函数最小时的参数$w$和$b$。<br>$$<br>\min_{w,b}L(w,b) &#x3D; -\sum_{x_i\in M}y_i(w\cdot x_i+b)<br>$$</p>
<p>那么，采用随机梯度下降法进行优化。首先随机一个$w_0$和$b_0$，接下来求梯度。</p>
<p>对于法向量$w$。<br>$$<br>\nabla_w L(w,b) &#x3D; -\sum_{x_i\in M}y_ix_i<br>$$</p>
<p>对于截距$b$<br>$$<br>\nabla_b L(w,b) &#x3D; -\sum_{x_i\in M}y_i<br>$$</p>
<p>于是，如果随机选取一个错误分类的数据，更新的方法就是<br>$$<br>\begin{cases}<br>w^* &#x3D; w-(-\eta y_ix_i)&#x3D;w+\eta y_ix_i \<br>b^* &#x3D; b-(-\eta y_i) &#x3D; b+\eta y_i<br>\end{cases}<br>$$</p>
<p>其中$\eta$就是学习率。</p>
<p>所以，适用于编程实现的算法应该是</p>
<ol>
<li>随机一个$w_0$, $b_0$</li>
<li>在训练集中选取一个数据$(x_i, y_i)$</li>
<li>如果$y_i(w\cdot x_i+b)\leq 0$</li>
<li>使用更新方法更新参数</li>
<li>循环到step2，直到感知机不会产生错误分类的数据。</li>
</ol>
<p>至此，感知机的构建，学习策略和最优化算法阐述完毕。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>传统算法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>统计学习</tag>
      </tags>
  </entry>
  <entry>
    <title>无线通信基础——“单跳”与“多跳”</title>
    <url>/2022/04/07/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E2%80%9C%E5%8D%95%E8%B7%B3%E2%80%9D%E4%B8%8E%E2%80%9C%E5%A4%9A%E8%B7%B3%E2%80%9D/</url>
    <content><![CDATA[<h1 id="单跳（single-hop）的定义"><a href="#单跳（single-hop）的定义" class="headerlink" title="单跳（single-hop）的定义"></a>单跳（single-hop）的定义</h1><p>在传统的无限局域网中，每个客户端均通过一条与AP链接的无限链路来访问网络，用户如果要进行相互通信的话，必须首先访问一个固定的接入点，这种网络称为单跳网络（single-hop）。</p>
<h1 id="多跳（multi-hop）的定义"><a href="#多跳（multi-hop）的定义" class="headerlink" title="多跳（multi-hop）的定义"></a>多跳（multi-hop）的定义</h1><p>在无线网络中，任何无限设备点都可以同时作为AP和路由器，网络中的每个节点都可以发送和接受信号，每个节点都可以与一个或多个对等节点进行直接通信，这种网络称为多跳网络（multi-hop）。</p>
<p>也可以这样理解，即信息的传输是通过链路上的多个节点转发完成的，每个节点都可以与一个或者多个对等节点进行直接通信，多跳就是多次转发。</p>
<h1 id="多跳中间节点的具体阐释及应用"><a href="#多跳中间节点的具体阐释及应用" class="headerlink" title="多跳中间节点的具体阐释及应用"></a>多跳中间节点的具体阐释及应用</h1><p>在无线多跳网络中，源结点到目的结点之间的典型路径是由多跳组成的，该路径上的中间结点充当转发结点。因此，无线多跳网络中一个结点具有两种功能：</p>
<p>1.充当端结点产生或接受数据分组；<br>2.充当路由器对来自其它结点的数据分组进行转发。<br>主要应用有：无线Ad Hoc网络，无线传感器网络以及无线Mesh网络等。</p>
]]></content>
      <categories>
        <category>无线通信基础</category>
      </categories>
  </entry>
  <entry>
    <title>典型的环节与系统方框图(Control_typical_block)</title>
    <url>/2022/03/21/%E5%85%B8%E5%9E%8B%E7%9A%84%E7%8E%AF%E8%8A%82%E4%B8%8E%E7%B3%BB%E7%BB%9F%E6%96%B9%E6%A1%86%E5%9B%BE(Control_typical_block)/</url>
    <content><![CDATA[<h1 id="典型的环节与系统方框图-Control-typical-block"><a href="#典型的环节与系统方框图-Control-typical-block" class="headerlink" title="典型的环节与系统方框图(Control_typical_block)"></a>典型的环节与系统方框图(Control_typical_block)</h1><h2 id="1-典型环节"><a href="#1-典型环节" class="headerlink" title="1 典型环节"></a>1 典型环节</h2><p>所谓环节就是具有相同形式传递函数的原部件的分类。这些传递函数是控制系统最经典最典型的。</p>
<h3 id="1-1-比例环节"><a href="#1-1-比例环节" class="headerlink" title="1.1 比例环节"></a>1.1 比例环节</h3><p>传递函数<br>$$<br>G(s) &#x3D; K<br>$$</p>
<p>这个系统就是将输入乘以一个常数K输出，所以叫做比例环节。典型的比例环节部件就是电位计，根据电阻指针的位置有对应比例的输出。</p>
<h3 id="1-2-微分环节"><a href="#1-2-微分环节" class="headerlink" title="1.2 微分环节"></a>1.2 微分环节</h3><p>传递函数<br>$$<br>G(s) &#x3D; s<br>$$</p>
<p>不难发现，这就是Laplace变换微分定理，将输入乘以s，就是在时域微分。</p>
<h3 id="1-3-积分环节"><a href="#1-3-积分环节" class="headerlink" title="1.3 积分环节"></a>1.3 积分环节</h3><p>传递函数<br>$$<br>G(s) &#x3D; \frac{1}{s}<br>$$</p>
<p>这也是Laplace变换的积分定理，将输入除以s，就是在时域积分。</p>
<h3 id="1-4-惯性环节"><a href="#1-4-惯性环节" class="headerlink" title="1.4 惯性环节"></a>1.4 惯性环节</h3><p>传递函数<br>$$<br>G(s) &#x3D; \frac{1}{Ts+1}<br>$$</p>
<p>这个函数其实描述了一个缓慢消失的过程，我们把它的时域函数写出来。<br>$$<br>h(t) &#x3D; \frac{1}{T}e^{-\frac{t}{T}}<br>$$</p>
<p>随着时间增加，函数值按指数减少，就像是因为惯性而保持一段距离，最后消失，其中$T$就是<strong>时间常数</strong>，它决定了系统衰减的速度。</p>
<h3 id="1-5-震荡环节"><a href="#1-5-震荡环节" class="headerlink" title="1.5 震荡环节"></a>1.5 震荡环节</h3><p>传递函数<br>$$<br>G(s) &#x3D; \frac{1}{T^2s^2+2\xi Ts+1}<br>$$</p>
<p>函数描述的是一种震荡的状态，将在后面的二阶系统响应分析中详细介绍。</p>
<h3 id="1-6-一阶复合微分环节"><a href="#1-6-一阶复合微分环节" class="headerlink" title="1.6 一阶复合微分环节"></a>1.6 一阶复合微分环节</h3><p>传递函数<br>$$<br>\tau s+1<br>$$</p>
<p>暂不做介绍</p>
<h3 id="1-7-二阶复合微分环节"><a href="#1-7-二阶复合微分环节" class="headerlink" title="1.7 二阶复合微分环节"></a>1.7 二阶复合微分环节</h3><p>传递函数<br>$$<br>\tau^2s^2+2\xi \tau s+1<br>$$</p>
<p>暂不做介绍。</p>
<h3 id="1-8总结"><a href="#1-8总结" class="headerlink" title="1.8总结"></a>1.8总结</h3><p>任何的传递函数都可以看作典型环节的组合，这些典型环节可以构成多种多样的系统。</p>
<h2 id="2-负载效应问题"><a href="#2-负载效应问题" class="headerlink" title="2 负载效应问题"></a>2 负载效应问题</h2><p>现考虑两个电路连接在一起，第一级电路输入$u_r$，输出$u_a$，第二级电路输入$u_a$，输出$u_c$。但我们都知道，简单的耦合两个电路，第二级电路实际上会对第一级电路造成影响，这就叫做负载效应。对系统接入负载的时候，可能会导致系统不是简单的输入输出关系。</p>
<h2 id="3-系统方框图"><a href="#3-系统方框图" class="headerlink" title="3 系统方框图"></a>3 系统方框图</h2><p>描述控制系统的一大方式就是使用方框图，用有向线段表示信号的流通方向，方框表示系统模块，圆形表示加法器。方框图指明了信号的流动以及各部分对于信号的处理。</p>
<p>有了系统的方框图，下一步就是求解整个系统的传递函数。</p>
<h2 id="4-传递函数求解"><a href="#4-传递函数求解" class="headerlink" title="4 传递函数求解"></a>4 传递函数求解</h2><h3 id="4-1-消解系数法"><a href="#4-1-消解系数法" class="headerlink" title="4.1 消解系数法"></a>4.1 消解系数法</h3><p>把方框图所有的信号写出来，根据信号的处理把模块输入和输出的关系写出来，然后把中间变量全部消除，的到最终输出与输入的关系。这种方法最简单，但在系统变得很复杂的时候不简便。</p>
<h3 id="4-2-结构图等效变换法"><a href="#4-2-结构图等效变换法" class="headerlink" title="4.2 结构图等效变换法"></a>4.2 结构图等效变换法</h3><p>结构图有很多等效变换的法则，灵活使用它们可以将系统的传递函数找出来，这个过程也叫做化简。</p>
<h4 id="4-2-1-反馈等效"><a href="#4-2-1-反馈等效" class="headerlink" title="4.2.1 反馈等效"></a>4.2.1 反馈等效</h4><p>系统前向模块是$G(s)$，反馈模块是$H(s)$，系统等效为</p>
<p>$$<br>\frac{G(s)}{1+G(s)H(s)}<br>$$</p>
<div align=center> 
<img src="https://pic.imgdb.cn/item/62209e4f5baa1a80abc346de.jpg"></img>
<div align=left>


<h4 id="4-2-2-串联等效"><a href="#4-2-2-串联等效" class="headerlink" title="4.2.2 串联等效"></a>4.2.2 串联等效</h4><p>系统$G_1(s)$与$G_2(s)$串联，等效为<br>$$<br>G_1(s)\cdot G_2(s)<br>$$</p>
<div align=center> 
<img src="https://pic.imgdb.cn/item/62209dfd5baa1a80abc3158d.jpg"></img>
<div align=left>

<h4 id="4-2-3-并联等效"><a href="#4-2-3-并联等效" class="headerlink" title="4.2.3 并联等效"></a>4.2.3 并联等效</h4><p>系统$G_1(s)$与$G_2(s)$并联，等效为<br>$$<br>G_1(s)+G_2(s)<br>$$</p>
<h4 id="4-3-4-比较点前移"><a href="#4-3-4-比较点前移" class="headerlink" title="4.3.4 比较点前移"></a>4.3.4 比较点前移</h4><blockquote>
<p>加法器也叫比较器，因为它将两个输入的信号进行相减(信号1加上负的信号2)</p>
</blockquote>
<p>比较点在$G(s)$后面，相当于没有经过$G(s)$，前移过后信号就经过$G(s)$了，这时候需要乘以逆系统$\frac{1}{G(s)}$。</p>
<div align=center> 
<img src="https://pic.imgdb.cn/item/62209e425baa1a80abc33dc6.jpg"></img>
<div align=left>

<h4 id="4-3-5-比较点后移"><a href="#4-3-5-比较点后移" class="headerlink" title="4.3.5 比较点后移"></a>4.3.5 比较点后移</h4><p>反过来，比较点本来在$G(s)$前面，相当于经过了$G(s)$，后移之后就没有经过$G(s)$了，所以要补上一个$G(s)$。</p>
<div align=center> 
<img src="https://pic.imgdb.cn/item/62209e125baa1a80abc32422.jpg"></img>
<div align=left>

<h4 id="4-3-6-引出点前移"><a href="#4-3-6-引出点前移" class="headerlink" title="4.3.6 引出点前移"></a>4.3.6 引出点前移</h4><p>引出点在系统后面，则原信号是经过了系统的，移到前面之后就相当于没有经过系统就引出了，则需要补上一个$G(s)$</p>
<div align=center> 
<img src="https://pic.imgdb.cn/item/62209e245baa1a80abc32da1.jpg"></img>
<div align=left>

<h4 id="4-3-7-引出点后移"><a href="#4-3-7-引出点后移" class="headerlink" title="4.3.7 引出点后移"></a>4.3.7 引出点后移</h4><p>引出点在系统前面，则原信号没有经过系统，移到后面之后就相当于经过了系统才引出，所以需要乘以一个逆系统$\frac{1}{G(s)}$</p>
<div align=center> 
<img src="https://pic.imgdb.cn/item/62209e375baa1a80abc338b6.jpg"></img>
<div align=left>]]></content>
      <categories>
        <category>通信工程本科</category>
        <category>大三下</category>
        <category>自动控制原理</category>
      </categories>
      <tags>
        <tag>控制系统</tag>
        <tag>自动控制原理</tag>
      </tags>
  </entry>
  <entry>
    <title>移动通信基础——TCP三次握手和四次挥手</title>
    <url>/2022/04/17/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>第一次握手：客户端发送syn包(syn&#x3D;x)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack&#x3D;x+1），同时自己也发送一个SYN包（syn&#x3D;y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack&#x3D;y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次握手”。</p>
<p>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</p>
<p>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p>
<p>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p>
<p>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>
]]></content>
      <categories>
        <category>移动通信基础</category>
      </categories>
  </entry>
  <entry>
    <title>移动通信基础——无线信道衰落</title>
    <url>/2022/04/26/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%97%A0%E7%BA%BF%E4%BF%A1%E9%81%93%E8%A1%B0%E8%90%BD/</url>
    <content><![CDATA[<h1 id="一、无线电波传播效应"><a href="#一、无线电波传播效应" class="headerlink" title="一、无线电波传播效应"></a>一、无线电波传播效应</h1><p>无线通信信道是一种时变信道，无线电信号通过信道时会遭受来自不同途径的衰落，接收信号总功率表现为路径损失，阴影衰落，多径效应三种效应的综合。<br>（多径传播：电波遇到各种障碍物时会发生反射、绕射和散射现象，会对直射波形成干涉，也就是收发信机之间是有多条路径传播的。）</p>
<p>1.路径损失：大范围内信号强度随距离变化（数百或数千个波长），应该是与距离的平方成正比，本质上表现为电波能量扩散现象。</p>
<p>2.阴影衰落：中范围信号电平中值慢变（数百个波长），由于传播环境中的地形起伏、建筑物及其他障碍物对电波遮蔽所引起的慢衰落，信号中值出现缓慢变动，衰落深度与频率、阻碍物有关。</p>
<p>3.多径效应（衰落）：小范围信号瞬时值快变（数十个波长），由于多径传播引起的快衰落，接收信号场强的瞬时值呈现快速变化。</p>
<h1 id="二、无线信道衰落"><a href="#二、无线信道衰落" class="headerlink" title="二、无线信道衰落"></a>二、无线信道衰落</h1><p>根据无线电波传播效应，通常将无线信道衰落分为两类：大尺度衰落和小尺度（小尺度一般与信号波长为一个量级）衰落，尺度指时间或者距离的大小。</p>
<h2 id="大尺度衰落："><a href="#大尺度衰落：" class="headerlink" title="大尺度衰落："></a>大尺度衰落：</h2><p>（包括传输损失、阴影衰落；大尺度衰落都是慢衰落，但是慢衰落不一定是大尺度衰落。）</p>
<p>传输损失（路径损失）：无线电信号通过大尺度距离的信道传输时，随传输路径的增加，电波能量扩散，导致接收信号平均功率衰减，其衰减量与传输距离有关，距离越大，衰减量越多。</p>
<p>阴影衰落：无线电信号在中尺度距离的信道中传输时，由于地形起伏或高大建筑物群等障碍物遮挡，在阻碍物的背后形成阴影区，导致接收信号平均功率随机变化。其衰落特性服从对数正态分布。</p>
<h2 id="小尺度衰落："><a href="#小尺度衰落：" class="headerlink" title="小尺度衰落："></a>小尺度衰落：</h2><p>（由多径效应或多普勒效应引起。当传输信道小尺度(距离或时间)变化时，无线电信号在传输过程中受周围阻碍物反射、绕射和散射，其幅度或相位快速变化。）</p>
<p>依据多径效应产生的时延扩展，将小尺度衰落划分为频率选择性衰落（信道具有恒定增益且线性相位的带宽范围小于发送信号带宽）和频率非选择性&#x2F;平坦衰落（无线信道带宽大于发送信号的带宽，且在带宽范围内有恒定增益和线性相位）；</p>
<p>依据多普勒效应产生的多普勒（频域）扩展，将小尺度衰落划分为快衰落（信道的相干时间比发送信号的周期短，且基带信号的带宽小于多普勒扩展）和慢衰落（信道上的相干时间远远大于发送信号的周期，且基带信号的带宽远远大于多普勒扩展）。</p>
<h1 id="三、整体理解示意图"><a href="#三、整体理解示意图" class="headerlink" title="三、整体理解示意图"></a>三、整体理解示意图</h1><div align=center> 
<img src = 'https://s3.bmp.ovh/imgs/2022/05/09/47ced27228ee73bf.png'></img>
<div align=left>]]></content>
      <categories>
        <category>移动通信基础</category>
      </categories>
  </entry>
  <entry>
    <title>无线通信基础——网络传播时延(propagation delay)与传输时延(transmission delay)</title>
    <url>/2022/04/21/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E4%BC%A0%E6%92%AD%E6%97%B6%E5%BB%B6(propagation%20delay)%E4%B8%8E%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BB%B6(transmission%20delay)/</url>
    <content><![CDATA[<h1 id="传播时延-propagation-delay"><a href="#传播时延-propagation-delay" class="headerlink" title="传播时延(propagation delay)"></a>传播时延(propagation delay)</h1><p>数据（更确切地说是光电信号，因为数据在传输的时候，是隐藏在光电信号）从网络一端经过介质传播到另一端的时间。</p>
<h2 id="决定因素"><a href="#决定因素" class="headerlink" title="决定因素"></a>决定因素</h2><p>这主要取决于光电信号在介质中传播的速度，还有两端直接介质的长度。</p>
<h1 id="传输时延-transmission-delay"><a href="#传输时延-transmission-delay" class="headerlink" title="传输时延(transmission delay)"></a>传输时延(transmission delay)</h1><p>方便记忆的话，把传输时延改称为发射时延可能会更清晰一点。《计算机网络》（第七版，谢希仁编著）这本书上翻译为传输时延，对于汉语来说容易有歧义，后文也专门加了注解可以理解为发射。</p>
<h2 id="决定因素-1"><a href="#决定因素-1" class="headerlink" title="决定因素"></a>决定因素</h2><p>其实它指的是数据从开始发送，到发送完成需要的时间。这其实和信道传输速率有很大关系。注意这里说速率就没有歧义，说速度就有歧义。</p>
<h1 id="用于简易理解两者区分的类比"><a href="#用于简易理解两者区分的类比" class="headerlink" title="用于简易理解两者区分的类比"></a>用于简易理解两者区分的类比</h1><p>传输时延也称发送时延。</p>
<p>可以用公交车的例子来打比方。传输时延好比公交车开到站台前，站台上等候该公交的乘客从第一个上公交到最后一个上公交结束所花的时间便是传输时延；而公交车载着乘客从这一站开到下一站的路上所花的时间就是传播时延。</p>
<p>而在网络结构中，我们把数据发送到传播媒介上的过程便是乘客上车的过程；而数据通过电磁信号或光信号的形式在传播媒介上进行传播所花的时间便是传播时延。</p>
<h1 id="其他时延"><a href="#其他时延" class="headerlink" title="其他时延"></a>其他时延</h1><h2 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h2><p>分组在经过网络传输时，要经过许多的路由器。在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发</p>
<h2 id="节点处理时延"><a href="#节点处理时延" class="headerlink" title="节点处理时延"></a>节点处理时延</h2><p>节点进行报文存储转发处理（比如解析报文，查找路由表等）所产生的时间</p>
]]></content>
      <categories>
        <category>无线通信基础</category>
      </categories>
  </entry>
</search>
